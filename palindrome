//approach 1 : by checking overflow condition before multiply rev by 10

class Solution {
public:
    bool isPalindrome(int x) {
        int temp = x;
        int rev = 0;

        if(x < 0) return false;
        while(temp >0){
            int digit = temp%10;

             //check for overflow before multiply by 10 
            if(rev > INT_MAX/10 || (rev == INT_MAX/10 && digit > 7)) return 0;
            if(rev < INT_MIN/10 || (rev == INT_MIN/10 && digit < -8)) return 0;
            rev = rev*10+digit;
            temp/= 10;
        }

        return rev == x;        
    }
};


//Approach 2 : by reverse half the number and check if it equals half of the number
//In this approach if rev the number by half , it eliminate the chances of overflow  because reversing the whole number could cause overflow 

//so in this approach we reverse the number till original number > reversedhalf

//For even digits: x == reversedHalf

//For odd digits: The middle digit doesn't matter (e.g. 12321) â†’ so x == reversedHalf / 10

//code:

class Solution {
public:
    bool isPalindrome(int x) {

        //agar x negative hai and x ka lastdigit 0 hai pr x 0 nhi hai , to
        //uska palindrome nhi bnega to return kro false
        if(x<0 || x%10 == 0 && x!= 0) return false;
        int reversedhalf = 0;

        while(x>reversedhalf){
            reversedhalf = reversedhalf * 10 + x%10;
            x/=10;
        }

        return (x == reversedhalf || x == reversedhalf/10);
            
        }
};
